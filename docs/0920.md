# 分支覆盖测试

> 原文：<https://www.javatpoint.com/branch-coverage-testing-in-white-box-testing>

分支覆盖技术用于覆盖控制流图的所有分支。它至少覆盖一次决策点每个条件的所有可能结果(真和假)。分支覆盖技术是一种白盒测试技术，它确保每个决策点的每个分支都必须被执行。

然而，分支覆盖技术和决策覆盖技术非常相似，但两者之间有一个关键的区别。决策覆盖技术覆盖每个决策点的所有分支，而分支测试覆盖代码的每个决策点的所有分支。

换句话说，分支覆盖遵循决策点和分支覆盖边缘。许多不同的度量可以用来寻找分支覆盖和决策覆盖，但是一些最基本的度量是:寻找程序的百分比和程序执行期间的执行路径。

像决策覆盖一样，它也使用控制流图来计算分支的数量。

![Branch Coverage](img/c2ea453eff0b83b434259869c52b975e.png)

## 如何计算分行覆盖率？

计算分支覆盖有几种方法，但寻路是最常见的方法。

在这种方法中，执行分支的路径数被用来计算分支覆盖率。分支覆盖技术可以作为决策覆盖的替代。在某些地方，它并不被定义为一种单独的技术，但是它不同于决策覆盖，并且对于测试控制流图的所有分支是必不可少的。

**举个例子来理解一下:**

```

Read X
Read Y
IF X+Y > 100 THEN
Print "Large"
ENDIF
If X + Y<100 THEN
Print "Small"
ENDIF

```

这是基本的代码结构，我们取了两个变量 X 和 Y 以及两个条件。如果第一个条件为真，则打印“大”，如果为假，则转到下一个条件。如果第二个条件为真，则打印“小”

## 代码结构的控制流图

![Branch Coverage](img/f7f6b0f072751854ec3c4a8dba3436b4.png)

在上图中，描述了代码的控制流程图。在遍历“是”决策的第一种情况下，路径为 **A1-B2-C4-D6-E8** ，覆盖边数为 1、2、4、5、6 和 8，但边 3 和 7 在该路径中未被覆盖。为了覆盖这些边缘，我们必须遍历“否”决策。在“否”决策的情况下，路径是 A1-B3-5-D7，覆盖边的数量是 3 和 7。所以通过走这两条路，所有的分支都覆盖了。

```
Path 1 - A1-B2-C4-D6-E8
Path 2 - A1-B3-5-D7
Branch Coverage (BC) = Number of paths
    =2

```

| 情况 | 覆盖的树枝 | 小路 | 分支覆盖 |
| 是 | 1, 2, 4, 5, 6, 8 | A1-B2-C4-D6-E8 | Two |
| 不 | 3,7 | A1-B3-5-D7 |

* * *